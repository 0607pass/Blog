+++
date = '2025-12-20T21:11:20+08:00'
draft = false
title = '如何确保缓存和数据的一致性'
+++


## 0、为什么不考虑更新缓存
更新缓存的动作，相比于直接删除缓存，操作过程比较的复杂，而且也容易出错。

在"写写并发"的场景中，如果同时更新缓存和数据库，那么很容易会出现因为并发的问题导致数据不一致的情况。

先写数据库，再更新缓存
| 时间 | 线程 A | 线程 B | 数据库(DB) | 缓存(Cache) | 说明 |
|----|----|----|----|----|----|
| t1 | 写数据库：20 |  | 20 | 旧值 | A 先更新 DB |
| t2 |  | 写数据库：10 | 10 | 旧值 | B 后更新 DB |
| t3 |  | 写缓存：10 | 10 | 10 | B 更新缓存 |
| t4 | 写缓存：20 |  | 10 | 20 ❌ | A 覆盖缓存，产生不一致 |


先更新缓存，后写数据库：


| 时间 | 线程 A | 线程 B | 缓存(Cache) | 数据库(DB) | 说明 |
|----|----|----|----|----|----|
| t1 | 更新缓存：20 |  | 20 | 旧值 | A 写缓存 |
| t2 |  | 更新缓存：10 | 10 | 旧值 | B 覆盖缓存 |
| t3 |  | 写数据库：10 | 10 | 10 | B 写 DB |
| t4 | 写数据库：20 |  | 10 | 20 ❌ | A 后写 DB |

但是，**如果是做缓存的删除的话，在写写并发的情况下，缓存中的数据都是要被清除的，所以就不会出现数据不一致的问题。**

但是，删除缓存相比更新缓存还是有一个小的缺点，那就是带来的一次额外的cache miss，也就是说在删除缓存后的下一次查询会无法命中缓存，要查询一下数据库。

这种**cache miss**在某种程度上可能会导致缓存击穿，也就是刚好缓存被删除之后，同一个Key有大量的请求过来，导致缓存被击穿，大量请求访问到数据库。

## 1、先更新数据库，再删缓存
问题：
如果是读写分离架构会有以下问题
| 时间 | 线程 A（写）       | 线程 B（读）      |
| -- | ------------- | ------------ |
| t1 | 主库 UPDATE → 2 |              |
| t2 |               | 缓存 miss      |
| t3 |               | **从库读到旧值 1** |
| t4 | 删除缓存          |              |
| t5 |               | 回填缓存 = 1     |

如果是单点架构：

| 时间 | 线程 A（写）       | 线程 B（读）        | 数据库(DB) | 缓存(Cache) | 说明 |
|----|----------------|------------------|-----------|-------------|----|
| t1 | UPDATE → 2     |                  | 2         | 1           | DB 已更新 |
| t2 |                | 读缓存（命中）    | 2         | **1 ❌**     | 命中旧缓存 |
| t3 | 删除缓存        |                  | 2         | 无          | 缓存被清理 |
| t4 |                | 下次读缓存 miss | 2         | 无          |  |
| t5 |                | 查 DB 回填 = 2  | 2         | 2           | 一致恢复 |

概率较低 t2的时间窗口很短

## 2、先删缓存，更新数据库
问题：
| 时间 | 写线程       | 读线程      |
| -- | --------- | -------- |
| t1 | 删除缓存      |          |
| t2 |           | 读缓存未命中   |
| t3 |           | 查 DB（旧值） |
| t4 |           | 回填旧值     |
| t5 | 更新 DB（新值） |          |

概率比较大，时间窗口很大 ，更新DB是比较耗时的，这个时候可以考虑使用延迟双删，或者基于 cancal监听binglog实现删除，可不断重试。


## 延迟双删的 两次删除的必要性

**第一次**之所以要选择先删除缓存，而不是直接更新数据库，主要是因为先写数据库会存在一个比较关键的问题，那就是缓存的更新和数据库的更新不是一个原子操作，那么就存在失败的可能性。

如果写数据库成功了，但是删缓存失败了！那么就会导致数据不一致。

而如果先删缓存成功了，后更新数据库失败了，没关系，因为缓存删除了就删除了，又不是更新，不会有错误数据，也没有不一致问题。

并且，相对于缓存和数据库来说，数据库的失败的概率更大一些，并且删除动作和更新动作来说，更新的失败的概率也会更大一些。

所以，为了避免这个因为两个操作无法作为一个原子操作而导致的不一致问题，我们选择先删除缓存，再更新数据库。这是第一次删除缓存的原因。

**第二次**： 因为"读写并发"的问题会导致并发发生后，缓存中的数被读线程写进去脏数据，那么就只需要在写线程在删缓存、写数据库之后，延迟一段时间，再执行一把删除动作就行了。



