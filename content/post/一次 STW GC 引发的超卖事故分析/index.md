+++
date = '2026-01-03T13:39:13+08:00'
draft = false
title = '一次 STW GC 引发的超卖事故分析'
tags = ['JVM', '并发', 'GC']
categories = ['JVM']
image = "images/postCover/java.png"
+++

## 事故现场

第一个线程要去创建订单，正好要去数据库创建订单的时候 发生gc 发生了stw gc结束之后， 后查询请求进来后 先拿到了cpu进行了回滚库存操作，这个时候创建订单那个请求又拿到了cpu 就出现了 超卖

## 一、这段话到底在说什么？

这事儿我一开始也懵，后来仔细想了想，其实是个挺隐蔽的并发问题。

**简单说就是：**

线程A扣完库存，正准备创建订单，结果JVM突然STW GC，整个世界暂停了。GC结束后，线程B先抢到CPU，发现订单不存在就把库存回滚了。然后线程A才恢复，继续创建订单成功。

**结果：** 订单有了，但库存被误回滚，导致超卖。

## 二、完整时间线（一步一步看）

假设场景：
- Redis库存还剩1件
- 用的是"失败就回滚库存"的方案
- 没有冻结库存状态

### 线程A（用户下单）

**T1：** Redis扣库存成功，库存=0

**T2：** 准备插入数据库订单

**T3：** JVM突然STW GC，线程A被暂停

> ⚠️ STW是"整个JVM所有线程"都暂停，不是只有线程A

---

### GC结束后

**GC结束 ≠ 线程A立即恢复**

操作系统重新调度，谁先抢到CPU不确定

---

### 线程B（补偿逻辑）

**T4：** 线程B抢到CPU，进入订单失败补偿

**T5：** 反查数据库，订单还没创建（线程A还没来得及insert）

**T6：** 判定订单不存在，回滚库存，库存+1

> 📌 此时库存已经被误回滚

---

### 线程A恢复

**T7：** 线程A抢到CPU，继续执行insert，订单创建成功

## 三、最终结果

| 项目 | 状态 |
|------|------|
| 订单表 | 有订单 |
| Redis库存 | 1（被误回滚） |
| 实际卖出 | 1件，但库存显示还剩1件 |

**下一个用户进来又能买，超卖了！**

## 四、为什么会出现这种情况？

### 1. STW GC不可控

Full GC、CMS remark、G1 mixed都会STW。ZGC虽然短，但也不是0。

**任何JVM都无法避免STW。**

### 2. 业务逻辑假设错了

我们假设：线程A要么成功，要么失败。

但现实是：
- 线程可以被任意时刻暂停
- 恢复顺序不可预测
- 补偿逻辑可能在订单创建之前执行

### 3. 数据库状态 ≠ 真实状态

补偿逻辑查数据库："现在有没有订单？"

但应该问的是："这个请求最终会不会创建订单？"

**这是根本性的逻辑错误。**

## 五、核心问题

**你用"当前瞬时状态"去判断"未来会不会成功"。**

但JVM + OS + GC完全不保证这个时序。


## 怎么解决？

**正确做法：** 不要在同步链路中回滚库存，而是引入库存冻结状态或异步补偿机制，确保库存回退只发生在订单进入终态之后。

---
