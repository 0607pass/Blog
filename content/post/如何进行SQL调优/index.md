+++
date = '2025-12-11T10:48:40+08:00'
draft = true
title = '如何进行SQL调优'
tags = ['MySQL']
categories = ['DB']
image = "images/postCover/sql.png"
+++
# 1、如何进行SQL调优
## 1.1 定位慢SQL
首先需要定位到具体的SQL语句，这个可以通过各类监控平台或者工具来实现，通过定位到SQL语句之后，就能知道具体是哪张表、哪个SQL慢了。
## 1.2 分析慢SQL
慢SQL可能有以下原因
* 索引失效
* 多表join
* 查询字段太多
* 表中数据量太大
* 索引区分度不高
* 数据库连接数不够
* 数据库表的结构设计不合理
* 数据库IO或者CPU比较高
* 数据库参数不合理
* 事务比较长
* 锁竞争导致的等待
* 深分页问题
### 1.2.1 索引失效问题
索引失效的问题一般是先通过执行计划分析是否走了索引，以及所走的索引是否符合预期，如果因为索引设计的不合理、或者索引失效导致的，那么就可以修改索引，或者修改SQL语句。或者强制执行使用某个索引。

```sql
CREATE TABLE `t2` (          
  `id` INT(11),
  `a` varchar(64) NOT NULL,                                             
  `b` varchar(64) NOT NULL,                                                        
  `c` varchar(64) NOT NULL,                                                     
  `d` varchar(64) NOT NULL,                                                   
  `f` varchar(64) DEFAULT NULL,    
  PRIMARY KEY(id),
  UNIQUE KEY `f` (`f`),                                                          
  KEY `idx_abc` (`a`,`b`,`c`)                                                   
) ENGINE=InnoDB DEFAULT CHARSET=latin1
INSERT INTO t2 (id, a, b, c, d, f) VALUES
(1, 'a1', 'b1', 'c1', 'd1', 'f001'),
(2, 'a2', 'b2', 'c2', 'd2', 'f002'),
(3, 'a3', 'b3', 'c3', 'd3', 'f003'),
(4, 'a4', 'b4', 'c4', 'd4', 'f004'),
(5, 'a5', 'b5', 'c5', 'd5', 'f005'),
(6, 'a6', 'b6', 'c6', 'd6', 'f006'),
(7, 'a7', 'b7', 'c7', 'd7', 'f007'),
(8, 'a8', 'b8', 'c8', 'd8', 'f008'),
(9, 'a9', 'b9', 'c9', 'd9', 'f009'),
(10, 'a10', 'b10', 'c10', 'd10', 'f010'),
(11, 'a11', 'b11', 'c11', 'd11', 'f011'),
(12, 'a12', 'b12', 'c12', 'd12', 'f012'),
(13, 'a13', 'b13', 'c13', 'd13', 'f013'),
(14, 'a14', 'b14', 'c14', 'd14', 'f014'),
(15, 'a15', 'b15', 'c15', 'd15', 'f015')
```



> explain 查看SQL的执行计划，主要关注type、key和extra这几个字段。 一个执行计划中，共有12个字段
1. **id: **执行计划中每个操作的唯一标识符。对于一条查询语句，每个操作都有一个唯一的id。但是在多表join的时候，一次explain中的多条记录的id是相同的。

2. **select_type：**操作的类型。常见的类型包括**SIMPLE、PRIMARY、SUBQUERY、UNION**等。不同类型的操作会影响查询的执行效率。

3. **table：**当前操作所涉及的表。

4. partitions：当前操作所涉及的分区。

5. type：表示查询时所使用的索引类型，包括**ALL、index、range、ref、eq_ref、const、system**等。
   1. system：系统表，少量数据，往往不需要进行磁盘IO

   2. constant: 使用常数索引，MySQL 只会在查询时使用常数值进行匹配。
      * `explain select * from t2 where f='f010';`
      * 使用唯一性索引做唯一查询

   3. eq_ref：唯一索引扫描，只会扫描索引树中的一个匹配行。
      * `explain select * from t1 join t2 on t1.id = t2.id where t1.f1 = 's';`
      * 当在连接操作中使用了唯一索引或主键索引，并且连接条件是基于这些索引的等值条件时，MySQL通常会选择 eq_ref 连接类型，以提高查询性能。 

   4. ref：非唯一索引扫描， 只会扫描索引树中的一部分来查找匹配的行。（使用非唯一索引进行查询）
      * `explain select * from t2 where a = 'a15';`
      * 使用非唯一索引进行查询

   5. range：范围扫描， 只会扫描索引树中的一个范围来查找匹配的行。
      * `explain select * from t2 where a > 'a' and a < 'a15';`
      * 使用索引进行性范围查询

   6. index：全索引扫描， 会遍历索引树来查找匹配的行

      * `explain select c from t2 where b = 'b1';`
      * 不符合最左前缀匹配的查询

   7. ALL：全表扫描， 将遍历全表来找到匹配的行。

      * explain select * from t2 where d = "d10";
      * 使用非索引字段查询

      > 需要注意的是，这里的index表示的是做了索引树扫描，效率并不高。以上类型由快到慢：
      > system> const > eq_ref >ref>range> index >ALL

6. **possible_keys：**表示可能被查询优化器选择使用的索引。

7. **key：**表示查询优化器选择使用的索引。

8. key_len：表示索引的长度。索引的长度越短，查询时的效率越高。

9. ref：用来表示哪些列或常量被用来与key列中命名的索引进行比较。

10. rows：表示此操作需要扫描的行数，即扫描表中多少行才能得到结果。

11. filtered：表示此操作过滤中保留的的行数占扫描行数的百分比。 

12. **Extra：**表示其他额外的信息，包括Using index、Using filesort、Using temporary等。

    * Using where：表示 MySQL 将在存储引擎检索行后，再进行条件过滤（使用 WHERE 子句）；查询的列未被索引覆盖，where筛选条件非索引的前导列或者where筛选条件非索引列。
      * explain select * from t2 where d = "d5";   非索引字段查询
      * explain select d from t2 where b = "b5";   未索引覆盖，用联合索引的非前导列查询
    * Using index：表示 MySQL 使用了覆盖索引（也称为索引覆盖）优化，只需要扫描索引，而无需回到数据表中检索行；
      * explain select b,c from t2 where a = "a5";  索引覆盖
    * Using index condition：表示查询在索引上执行了部分条件过滤。这通常和索引下推有关。
      * explain select d from t2 where a = "a5" and b like "b%";   使用到索引下推。
    * Using where; Using index：查询的列被索引覆盖，并且where筛选条件是索引列之一，但不是索引的前导列，或者where筛选条件是索引列前导列的一个范围
      * `explain select a from t2 where b = "b5";`   索引覆盖，但是不符合最左前缀
      * `explain select b from t2 where a in ('a1','a5','a6');`   索引覆盖，但是前导列是个范围
    * Using join buffer：表示 MySQL 使用了连接缓存；
      *  `explain select * from t1 join t2 on t1.id = t2.id where a = 'a1'`;
    * Using temporary：表示 MySQL 创建了临时表来存储查询结果。这通常是在排序或分组时发生的；
    * Using filesort：表示 MySQL 将使用文件排序而不是索引排序，这通常发生在无法使用索引来进行排序时；
      *  explain select count(*),b  from t2 group by b; 
    * Using index for group-by：表示 MySQL 在分组操作中使用了索引。这通常是在分组操作涉及到索引中的所有列时发生的；
    * Using filesort for group-by：表示 MySQL 在分组操作中使用了文件排序。这通常发生在无法使用索引进行分组操作时；
    * Range checked for each record：表示 MySQL 在使用索引范围查找时，需要检查每一条记录；
    * Using index for order by：表示 MySQL 在排序操作中使用了索引，这通常发生在排序涉及到索引中的所有列时；
    * Using filesort for order by：表示 MySQL 在排序操作中使用了文件排序，这通常发生在无法使用索引进行排序时；
    * Using index for group-by; Using index for order by：表示 MySQL 在分组和排序操作中都使用了索引。

> 如果通过执行计划之后，发现一条SQL没有走索引，比如 type = ALL， key = NULL , extra = Using where
>
> 那么就要进一步分析没有走索引的原因了。我们需要知道的是，到底要不要走索引，走哪个索引，是MySQL的优化器决定的，他会根据预估的成本来做一个决定。有以下这么几种情况可能会导致没走索引：
>
> 1、没有正确创建索引：当查询语句中的where条件中的字段，没有创建索引，或者不符合最左前缀匹配的话，就是没有正确的创建索引。
> 2、索引区分度不高：如果索引的区分度不够高，那么可能会不走索引，因为这种情况下走索引的效率并不高。
> 3、表太小：当表中的数据很小，优化器认为扫全表的成本也不高的时候，也可能不走索引
> 4、查询语句中，索引字段因为用到了函数、类型不一致等导致了索引失效
>
> 如何解决？
>
> 1、如果没有正确创建索引，那么就根据SQL语句，创建合适的索引。如果没有遵守最左前缀那么就调整一下索引或者修改SQL语句
> 2、索引区分度不高的话，那么就考虑换一个索引字段。
> 3、表太小这种情况确实也没啥优化的必要了，用不用索引可能影响不大的
> 4、排查具体的失效原因，然后针对性的调整SQL语句就行了。
>
> **可能导致索引失效的情况**？？？



### 1.2.2 多表join问题
> 为什么大厂不建议使用多表join？
>
> 最主要的原因就是join的效率比较低。
>
> MySQL是使用了嵌套循环（Nested-Loop Join）的方式来实现关联查询的，简单点说就是要通过两层循环，用第一张表做外循环，第二张表做内循环，外循环的每一条记录跟内循环中的记录作比较，符合条件的就输出。
>
> 而具体到算法实现上主要有simple nested loop，block nested loop和index nested loop这三种。而且这三种的效率都没有特别高。
>
> MySQL是使用了嵌套循环（Nested-Loop Join）的方式来实现关联查询的，如果有2张表join的话，复杂度最高是O(n^2)，3张表则是O(n^3)...随着表越多，表中的数据量越多，JOIN的效率会呈指数级下降。

**不能用join如何做关联查询** 

1、在内存中自己做关联，即先从数据库中把数据查出来之后，我们在代码中再进行二次查询，然后再进行关联。

2、数据冗余，那就是把一些重要的数据在表中做冗余，这样就可以避免关联查询了。

3、宽表，就是基于一定的join关系，把数据库中多张表的数据打平做一张大宽表，可以同步到ES或者干脆直接在数据库中直接查都可以	



### 1.2.3 索引区分度不高问题

这个其实也和索引不合理有关，但是其实到底快不快，用不用索引，并不是因为区分度高不高导致，其实还是索引扫描的行数的成本导致。所以，有的时候不能认为区分度不高就一定会效率低，或者一定就不适合创建索引。

**区分度不高的字段建索引一定没用吗？**

>  不一定 看索引扫描的行数的成本 
>
> 例如表中有一个性别字段，他的区分度肯定是不高的，只有男和女两种。一般情况下，如果表中数据量很大的话，用这个字段查询会导致没办法过滤掉很多数据，就可能没办法发挥索引的效果。
>
> 但是，如果有一种特殊情况，如男女比例是95:5，那么，这时候，如果我用"女'作为性别的查询条件的话，还是可以走索引，并且有很大的性能提升的，原因就是因为他可以过滤掉大部分数据。走索引可以大大提升效率。
>
> 这种一般在任务表中比较多，比如任务表中有状态，两种情况：FAIL和SUCCESS，大多数情况下，任务都是SUCCESS的，只有一少部分是FAIL，这时候就可以给这个字段加索引。这样当我们扫描任务表执行任务的时候，还是可以大大提升查询效率的。

### 1.2.4 查询字段太多

查询字段太多，这个有的时候是因为我们错误的用到了select * 导致的，一般来说，查询字段小于100个，都不是特别大的问题，除非真的是字段数特别多，这时候可以采用两种办法解决。第一个就是不要查询那些你不关心的字段，只查询少部分字段。第二个就是做分表，垂直分表，把数据拆分到多张表中。但是这么做可能也会带来需要多表join的问题，所以拆分的时候也需要考虑冗余。

### 1.2.5 表中数据量太大

一般来说，单表超过1000万，会导致查询效率变低，即使使用索引可能也会比较慢，所以如果表中数据量太大的话，这时候可能通过建索引并不一定能完全解决了。那么具体的解决方案有几种：

1、数据归档，把历史数据移出去，比如只保留最近半年的数据，半年前的数据做归档。
2、分库分表、分区。把数据拆分开，分散到多个地方去。
3、使用第三方的数据库，比如把数据同步到支持大数量查询的分布式数据库中，如oceanbase、tidb，或者搜索引擎中，如ES等。

### 1.2.6 **数据库连接数不够**

这个也需要具体分析，到底是什么原因，可能的原因有几个，第一个就是业务量太大了，单库确实扛不住了，那就选择分库吧。

也可能就是存在一些慢SQL、或者长事务导致的，慢SQL占用数据库链接，数据库连接数不够，其他的查询就会阻塞，就更慢。



数据库的表结构不合理，这个也是一个关键原因，有的时候比如某个字段中存了很长的内容，或者没有做合理的冗余需要多表关联查询等等。解决思路就是重构，或者分表。

数据库IO或者CPU比较高，这种问题也常见的，当数据库整体IO或者CPU飙高的时候，查询速度就有可能下降，所以需要分析背后的原因及解决思路

存在长事务，这个和慢SQL同理，都是占用了数据库链接，导致其他请求要等待。



锁竞争导致的等待，当有大并发争抢共享资源的时候，就会导致锁等待，这个过程就会拉长耗时，导致SQL变慢。这个也可以参考上面的CPU被打满的问题。



数据库参数不合理，这个也是经常会遇到的，针对我们具体的业务场景，做一些适当的参数调整，有时候也能大大的提升SQL的效率。比如调整内存大小、缓存大小、线程池大小等。



深度分页问题是指在数据库查询中，当你尝试访问通过分页查询返回的结果集的后面部分（即深层页码）时遇到的性能问题。可以考虑使用子查询以及记录上一页ID的方案解决。



##  1.3 参数优化 

 假设我们有一个名为 mydb 的数据库，其中包含一个名为 mytable 的 InnoDB 表。该表有一个自增主键 id，一个整数类型字段 age 和一个字符串类型字段 name，我们希望对该表进行优化。

首先，我们可以使用 SHOW VARIABLES LIKE 'innodb%'; 命令查看当前的 InnoDB 参数设置。这些参数包括缓冲池大小、刷新间隔、日志大小等等。



接下来，我们可以尝试调整以下几个参数来优化数据库性能：

innodb_buffer_pool_size: 缓冲池大小是 InnoDB 存储引擎的核心参数之一，它控制着 InnoDB 存储引擎使用的内存大小。通常，我们可以将该参数设置为系统可用内存的 70%-80%。例如，如果系统有 8GB 内存可用，我们可以将 innodb_buffer_pool_size 设置为 6GB。在 MySQL 中，可以使用以下命令进行设置：

```sql
SET GLOBAL innodb_buffer_pool_size=6G;
```

**innodb_read_io_threads** 和 **innodb_write_io_threads**: 这两个参数控制 InnoDB 存储引擎使用的 I/O 线程数量。通常情况下，我们可以将这两个参数设置为 CPU 核心数的一半。在 MySQL 中，可以使用以下命令进行设置：

```sql
SET GLOBAL innodb_read_io_threads=4;
SET GLOBAL innodb_write_io_threads=4;
```

**innodb_log_file_size:** 这个参数控制事务日志文件的大小。这个值的默认为5M，是远远不够的。在 MySQL 中，可以使用以下命令进行设置：

```sql
SET GLOBAL innodb_log_file_size=1G;
```

一般在设置这个字段的时候，都是需要先进行数据采样，看一下一般在业务高峰期，2小时左右可以写入多少日志，然后把这个量作为你的日志文件的大小即可。如果简单点的话，一般设置为1G左右，或者系统内存的1/4即可。



